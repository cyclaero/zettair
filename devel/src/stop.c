/* stop.c is a simple stoplist using the chash hashtable.
 *
 * written nml 2004-11-19
 *
 */

#include "firstinclude.h"

#include "stop.h"

#include "chash.h"
#include "def.h"
#include "poolalloc.h"
#include "str.h"

#include <assert.h>
#include <stdlib.h>
#include <string.h>

struct stop {
    struct chash *table;        /* hashtable of stopped terms */
    struct poolalloc *alloc;    /* allocator for term memory */

    /* stemming algorithm */
    void (*stem)(void *opaque, char *term);
    void *opaque;
};

struct stop *stop_new(void (*stem)(void *opaque, char *term), void *opaque) {
    struct stop *list;

    if ((list = malloc(sizeof(*list))) 
      && (list->alloc = poolalloc_new(!!DEAR_DEBUG, 1024, NULL))
      && (list->table = chash_ptr_new(1, 0.5, 
          (unsigned int (*)(const void *)) str_hash,
          (int (*)(const void *, const void *)) str_cmp))) {

        list->stem = stem;
        list->opaque = opaque;
    } else {
        if (list) {
            free(list);
            list = NULL;
        }
    }

    return list;
}

struct stop *stop_new_file(void (*stem)(void *opaque, char *term), 
  void *opaque, const char *filename) {
    struct stop *list;

    if ((list = stop_new(stem, opaque)) 
      && stop_add_file(list, filename) == STOP_OK) {
        /* succeeded, do nothing */
    } else {
        if (list) {
            stop_delete(list);
            list = NULL;
        }
    }

    return list;
}

void stop_delete(struct stop *list) {
    chash_delete(list->table);
    poolalloc_delete(list->alloc);
    list->alloc = NULL;
    free(list);
    return;
}

#define BUFSIZE 4096

enum stop_ret stop_add_file(struct stop *list, const char *filename) {
    char buf[BUFSIZE + 1];
    FILE *fp = fopen(filename, "rb");
    enum stop_ret sret;
    char *start;

    if (fp) {
        buf[BUFSIZE] = '\0';
        while (fgets(buf, BUFSIZE - 1, fp)) {
            if ((buf[str_len(buf) - 1] != '\n')
              && (buf[str_len(buf) - 1] != '\r')) {
                /* line too long */
                fclose(fp);
                return STOP_EINVAL;
            }

            str_rtrim(buf);
            start = (char *) str_ltrim(buf);

            if (*start && (*start != '#')) {
                if (((sret = stop_add_term(list, start)) != STOP_OK)
                  && (sret != STOP_EEXIST)) {
                    /* something went wrong (note that we allow
                     * duplicate entries in files) */
                    fclose(fp);
                    return sret;
                }
            }
        }

        fclose(fp);
        return STOP_OK;
    } else {
        switch (errno) {
        case EACCES: return STOP_EACCESS;
        default: return STOP_EINVAL;
        }
    }
}

enum stop_ret stop_add_term(struct stop *list, const char *term) {
    unsigned int len;
    char *copy;

    if (!list->stem && (stop_stop(list, term) == STOP_STOPPED)) {
        return STOP_EEXIST;
    }

    len = str_len(term);
    if ((copy = poolalloc_memalign(list->alloc, len + 1, 1))) {
        memcpy(copy, term, len + 1);
        assert(copy[len] == '\0');
        str_tolower(copy);
        if (list->stem) {
            list->stem(list->opaque, copy);
        }

        if (stop_stop(list, copy) == STOP_STOPPED) {
            return STOP_EEXIST;
        }

        if (chash_ptr_ptr_insert(list->table, copy, copy) == CHASH_OK) {
            return STOP_OK;
        } else {
            /* unfortunately, at this point there's nothing we can do
             * to reclaim the allocated memory for copy, we have to
             * wait until we delete the stoplist */
            return STOP_ENOMEM;
        }
    } else {
        return STOP_ENOMEM;
    }
}

enum stop_ret stop_stop(struct stop *list, const char *term) {
    void **data;

    if (chash_ptr_ptr_find(list->table, term, &data) == CHASH_OK) {
        assert(!str_cmp(*data, term));
        return STOP_STOPPED;
    } else {
        return STOP_OK;
    }
}

enum stop_ret stop_print(struct stop *list, FILE *output) {
    struct chash_iter *iter = chash_iter_new(list->table);
    const void *key;
    void **data;

    if (!iter) {
        return STOP_ENOMEM;
    }

    while (chash_iter_ptr_ptr_next(iter, &key, &data) == CHASH_OK) {
        fprintf(output, "%s\n", (const char *) key);
    }

    chash_iter_delete(iter);
    return STOP_OK;
}

enum stop_ret stop_write_code(struct stop *list, FILE *output) {
    struct chash_iter *iter = chash_iter_new(list->table);
    const void *key;
    void **data;

    if (!iter) {
        return STOP_ENOMEM;
    }

    fprintf(output, "/* code generated by stop_write_code() to produce a\n");
    fprintf(output, " * stoplist with default contents */\n\n");
    fprintf(output, "#include \"firstinclude.h\"\n\n");
    fprintf(output, "#include \"stop.h\"\n\n");
    fprintf(output, "struct stop *stop_new_default(void (*stem)(void *opaque,"
      " char *term),\n");
    fprintf(output, "  void *opaque) {\n");
    fprintf(output, "    struct stop *list = stop_new(stem, opaque);\n");
    fprintf(output, "    enum stop_ret ret;\n");
    fprintf(output, "    if (!list) {\n");
    fprintf(output, "        return NULL;\n");
    fprintf(output, "    }\n\n");

    while (chash_iter_ptr_ptr_next(iter, &key, &data) == CHASH_OK) {
        fprintf(output, "    if ((ret = stop_add_term(list, \"%s\")) "
          "!= STOP_OK\n      && ret != STOP_EEXIST) {\n", (const char *) key);
        fprintf(output, "        stop_delete(list);\n");
        fprintf(output, "        return NULL;\n");
        fprintf(output, "    }\n\n");
    }

    fprintf(output, "    return list;\n}\n\n");
    chash_iter_delete(iter);
    return STOP_OK;
}

#ifdef STOP_MAIN

int main(int argc, char **argv) {
    struct stop *list;
    FILE *outfp;

    if (argc > 3) {
        fprintf(stderr, "usage: %s [file] [outfile]\n", *argv);
        return EXIT_FAILURE;
    }

    if (argc > 2) {
        outfp = fopen(argv[2], "wb");

        if (!outfp) {
            perror(*argv);
            return EXIT_FAILURE;
        }
    } else {
        outfp = stdout;
    }

    if (argc <= 1) {
        fprintf(stderr, "usage: %s [file] [outfile]\n", *argv);
        return EXIT_FAILURE;
    }

    if ((list = stop_new_file(NULL, NULL, argv[1]))) {
        stop_write_code(list, outfp);
        fclose(outfp);
        stop_delete(list);
        return EXIT_SUCCESS;
    } else {
        fclose(outfp);
        fprintf(stderr, "failed to create stoplist object from stream\n");
        return EXIT_FAILURE;
    }
}

#endif

